// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package eks

import (
	"context"
	"reflect"

	"github.com/lbrlabs/pulumi-lbrlabs-eks/sdk/go/eks/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

var _ = internal.GetEnvOrDefault

// Represents a single requirement with key, operator, and values.
type Requirement struct {
	// The key of the requirement.
	Key *string `pulumi:"key"`
	// The operator for the requirement (e.g., In, Gt).
	Operator *string `pulumi:"operator"`
	// The list of values for the requirement.
	Values []string `pulumi:"values"`
}

// RequirementInput is an input type that accepts RequirementArgs and RequirementOutput values.
// You can construct a concrete instance of `RequirementInput` via:
//
//	RequirementArgs{...}
type RequirementInput interface {
	pulumi.Input

	ToRequirementOutput() RequirementOutput
	ToRequirementOutputWithContext(context.Context) RequirementOutput
}

// Represents a single requirement with key, operator, and values.
type RequirementArgs struct {
	// The key of the requirement.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// The operator for the requirement (e.g., In, Gt).
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// The list of values for the requirement.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (RequirementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Requirement)(nil)).Elem()
}

func (i RequirementArgs) ToRequirementOutput() RequirementOutput {
	return i.ToRequirementOutputWithContext(context.Background())
}

func (i RequirementArgs) ToRequirementOutputWithContext(ctx context.Context) RequirementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequirementOutput)
}

func (i RequirementArgs) ToOutput(ctx context.Context) pulumix.Output[Requirement] {
	return pulumix.Output[Requirement]{
		OutputState: i.ToRequirementOutputWithContext(ctx).OutputState,
	}
}

// RequirementArrayInput is an input type that accepts RequirementArray and RequirementArrayOutput values.
// You can construct a concrete instance of `RequirementArrayInput` via:
//
//	RequirementArray{ RequirementArgs{...} }
type RequirementArrayInput interface {
	pulumi.Input

	ToRequirementArrayOutput() RequirementArrayOutput
	ToRequirementArrayOutputWithContext(context.Context) RequirementArrayOutput
}

type RequirementArray []RequirementInput

func (RequirementArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Requirement)(nil)).Elem()
}

func (i RequirementArray) ToRequirementArrayOutput() RequirementArrayOutput {
	return i.ToRequirementArrayOutputWithContext(context.Background())
}

func (i RequirementArray) ToRequirementArrayOutputWithContext(ctx context.Context) RequirementArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequirementArrayOutput)
}

func (i RequirementArray) ToOutput(ctx context.Context) pulumix.Output[[]Requirement] {
	return pulumix.Output[[]Requirement]{
		OutputState: i.ToRequirementArrayOutputWithContext(ctx).OutputState,
	}
}

// Represents a single requirement with key, operator, and values.
type RequirementOutput struct{ *pulumi.OutputState }

func (RequirementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Requirement)(nil)).Elem()
}

func (o RequirementOutput) ToRequirementOutput() RequirementOutput {
	return o
}

func (o RequirementOutput) ToRequirementOutputWithContext(ctx context.Context) RequirementOutput {
	return o
}

func (o RequirementOutput) ToOutput(ctx context.Context) pulumix.Output[Requirement] {
	return pulumix.Output[Requirement]{
		OutputState: o.OutputState,
	}
}

// The key of the requirement.
func (o RequirementOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Requirement) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// The operator for the requirement (e.g., In, Gt).
func (o RequirementOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Requirement) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// The list of values for the requirement.
func (o RequirementOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Requirement) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type RequirementArrayOutput struct{ *pulumi.OutputState }

func (RequirementArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Requirement)(nil)).Elem()
}

func (o RequirementArrayOutput) ToRequirementArrayOutput() RequirementArrayOutput {
	return o
}

func (o RequirementArrayOutput) ToRequirementArrayOutputWithContext(ctx context.Context) RequirementArrayOutput {
	return o
}

func (o RequirementArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]Requirement] {
	return pulumix.Output[[]Requirement]{
		OutputState: o.OutputState,
	}
}

func (o RequirementArrayOutput) Index(i pulumi.IntInput) RequirementOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Requirement {
		return vs[0].([]Requirement)[vs[1].(int)]
	}).(RequirementOutput)
}

// Represents a taint for a karpenter node.
type Taint struct {
	// The effect of the taint.
	Effect []string `pulumi:"effect"`
	// The key of the taint.
	Key *string `pulumi:"key"`
	// The value of the taint.
	Value *string `pulumi:"value"`
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RequirementInput)(nil)).Elem(), RequirementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RequirementArrayInput)(nil)).Elem(), RequirementArray{})
	pulumi.RegisterOutputType(RequirementOutput{})
	pulumi.RegisterOutputType(RequirementArrayOutput{})
}
